<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Buoyancy & Float Planner</title>
<style>
  :root {
    --bg: #0f1417; --panel: #121b20; --panel-2: #0e171c; --text: #e6eef0; --muted: #b6c6cb;
    --teal: #10b5c4; --accent: #78f0ff; --danger: #ff4d4d; --danger-dark: #c0392b; --ok: #86ff8f;
    /* Water color for diagram */
    --water: #0a0f12;

    /* THEME STROKE PALETTE (dark defaults) */
    --cable-stroke: #10b5c4;     /* cable line */
    --wave-stroke:  #78f0ff;     /* surface wave */
    --wave-alpha:    0.1;        /* wave opacity */
    --dim-stroke:   #78f0ff;     /* dimension arrows/lines */
    --ext-stroke:   #8aa3ab;     /* extension dashed lines */
    --float-stroke: #000000;     /* float outline */
    --panel-border: rgba(120, 240, 255, .18);
  }
  
  :root[data-theme="light"] {
    --bg: #f4f7f8; --panel: #ffffff; --panel-2: #fdfdfd; --text: #1a2b34; --muted: #5a6c74;
    --teal: #009faf; --accent: #007a8c; --danger: #d93030; --danger-dark: #b02020; --ok: #28a745;
    /* Light theme water */
    --water: #d4e0e8;

    /* Light-adjusted strokes for contrast */
    --cable-stroke: #007a8c;
    --wave-stroke:  #007a8c;
    --wave-alpha:   0.35;
    --dim-stroke:   #007a8c;
    --ext-stroke:   #7a8a92;
    --float-stroke: #333333;
    --panel-border: #dddddd;
  }

  @keyframes pulse-danger {
    0% { stroke-width: 4px; stroke: var(--danger); }
    50% { stroke-width: 8px; stroke: #ffffff; }
    100% { stroke-width: 4px; stroke: var(--danger); }
  }
  
  /* Lazy float bobbing animation */
  @keyframes float-bob {
    0% { transform: translateY(0px); }
    50% { transform: translateY(3px); }
    100% { transform: translateY(0px); }
  }

  body {
    background: var(--bg); color: var(--text); font: 14px/1.5 system-ui; margin: 0; padding: 18px;
    display: flex; flex-direction: column; gap: 14px;
    transition: background 0.3s ease, color 0.3s ease;
  }
  
  .title-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
  }
  .title {
    text-align: center; font-weight: 800; font-size: 22px; text-transform: uppercase;
    background: linear-gradient(90deg, var(--accent), var(--teal));
    -webkit-background-clip: text; background-clip: text; color: transparent;
  }
  
  #themeToggle {
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    background: var(--panel);
    border: 1px solid var(--accent);
    color: var(--accent);
    font-size: 18px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #themeToggle:hover { filter: brightness(1.2); }
  
  .wrap { display: flex; gap: 14px; flex: 1; }
  @media (max-width: 960px) { .wrap { flex-direction: column; } }
  .panel {
    background: linear-gradient(180deg, var(--panel), var(--panel-2));
    border: 1px solid var(--panel-border);
    border-radius: 14px; padding: 12px;
    transition: background 0.3s ease, border-color 0.3s ease;
  }
  :root[data-theme="light"] .panel {
    box-shadow: 0 4px 12px rgba(0,0,0,0.03);
  }
  
  /* --- Main Diagram --- */
  #mainDiagramWrap {
    flex: 1; min-height: 280px; border-radius: 14px;
    background: linear-gradient(180deg, var(--panel-2) 50% - 12px, var(--water) 50% - 12px);
    display: flex; align-items: center; justify-content: center;
    padding: 10px; overflow: hidden;
  }
  :root[data-theme="light"] #mainDiagramWrap {
  background: linear-gradient(180deg, #edf2f5 calc(50% - 14px), var(--water) calc(50% - 14px));
  }
  #mainDiagramSVGContainer { width: 100%; }
  #mainDiagramSVGContainer svg { width: 100%; height: auto; max-height: 260px; }

  /* THEME-DRIVEN SVG STYLES */
  .main-svg .cable {
    stroke: var(--cable-stroke);
    stroke-width: 4;
    fill: none;
  }
  .main-svg .wave {
    stroke: var(--wave-stroke);
    stroke-width: 2;
    opacity: var(--wave-alpha);
    fill: none;
  }
  .main-svg .float-body { 
    stroke: var(--float-stroke);
    stroke-width: 1.5; 
    transition: all 0.2s ease;
    animation: float-bob 4s ease-in-out infinite;
  }
  .main-svg .float-body.overloaded {
    animation: pulse-danger 0.8s infinite;
  }
  .main-svg .dim-line {
    stroke: var(--dim-stroke);
    stroke-width: 1.5;
    marker-start: url(#arrow-main);
    marker-end: url(#arrow-main);
  }
  .main-svg .ext-line {
    stroke: var(--ext-stroke);
    stroke-width: 1;
    stroke-dasharray: 3 3;
  }
  .main-svg .dim-text { fill: var(--text); text-anchor: middle; font-weight: 600; font-size: 14px; }
  
  .sidebar, .math { width: 360px; max-width: 46vw; }
  @media (max-width: 960px) { .sidebar, .math { width: 100%; max-width: 100%; } }
  
  h2 { margin: 0 0 10px; font-size: 15px; font-weight: 800; text-transform: uppercase; color: var(--accent); }
  
  label {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 8px; color: var(--muted); gap: 10px; flex-wrap: wrap;
  }
  label span { flex: 1; min-width: 120px; }
  input, select {
    background: #0b1a20; border: 1px solid rgba(120, 240, 255, .25); color: var(--text);
    border-radius: 8px; padding: 6px 8px; width: 140px;
  }
  :root[data-theme="light"] input, :root[data-theme="light"] select {
    background: #f0f5f7;
    border: 1px solid #ccc;
  }
  
  input[type="text"] { width: 140px; }
  label.full-width-input { flex-direction: column; align-items: flex-start; }
  label.full-width-input span { margin-bottom: 4px; }
  label.full-width-input input { width: 100%; box-sizing: border-box; }
  
  select { padding-right: 20px; }
  input[type="color"] {
    padding: 2px;
    height: 32px;
  }

  .btn {
    background: linear-gradient(180deg, var(--teal), #0aa1b0); color: #04262b;
    border: 1px solid rgba(120, 240, 255, .35); border-radius: 8px; padding: 6px 10px; font-weight: 700;
    cursor: pointer; margin-top: 6px; text-align: center;
  }
  :root[data-theme="light"] .btn {
    color: #fff;
    border: 1px solid #007a8c;
  }
  .btn:hover { filter: brightness(1.1); }
  .btn-group { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
  .btn-group .btn { flex: 1; margin-top: 0; }
  
  .btn-danger {
    background: linear-gradient(180deg, var(--danger), var(--danger-dark));
    color: var(--text);
  }
  :root[data-theme="light"] .btn-danger { color: #fff; }
  
  .btn-secondary { background: #334; color: var(--muted); }
  :root[data-theme="light"] .btn-secondary {
    background: #e2e8ea;
    color: #333;
    border-color: #bbb;
  }

  table { width: 100%; font-size: 13px; margin-top: 10px; border-collapse: collapse; }
  td { padding: 4px; border-bottom: 1px solid rgba(120, 240, 255, .1); }
  :root[data-theme="light"] td { border-bottom: 1px solid #eee; }
  table tr:last-child td { border-bottom: none; }
  td:first-child { color: var(--muted); }
  td:last-child { color: var(--text); font-weight: 700; text-align: right; }
  
  .status-ok { color: var(--ok); }
  .status-bad { color: var(--danger); }

  .planner-result {
    margin-top: 16px; padding: 14px; background: var(--panel-2);
    border-radius: 10px; text-align: center; border: 1px solid var(--accent);
  }
  :root[data-theme="light"] .planner-result { border: 1px solid var(--teal); }
  
  .planner-result span {
    display: block; font-size: 13px; color: var(--muted); text-transform: uppercase;
  }
  #pt_floats_display {
    font-size: 36px; font-weight: 800; color: var(--accent);
    line-height: 1.2; margin-top: 4px;
  }
  
  #savedCards { display: flex; flex-direction: column; gap: 10px; margin-top: 16px; }
  .card {
    border: 1px solid var(--panel-border); border-radius: 10px; padding: 10px;
    background: linear-gradient(180deg, #0c1a20, #0b1519);
    cursor: default;
    transition: background 0.2s ease, border-color 0.3s ease;
  }
  :root[data-theme="light"] .card {
    background: linear-gradient(180deg, #fdfdfd, #f9fbfb);
  }
  
  .card-head { 
    display: flex; align-items: center; justify-content: space-between; 
    gap: 8px;
    cursor: pointer;
  }
  .card-title { font-weight: 800; color: var(--accent); flex: 1; }
  .card-grid { display: grid; grid-template-columns: 1fr auto; gap: 6px; font-size: 13px; }
  .card-grid-color {
    width: 25px; height: 20px;
    border: 1px solid var(--muted); border-radius: 4px;
  }
  .card-controls { display: flex; gap: 4px; }
  .card-controls button {
    background: var(--panel);
    color: var(--text);
    border: 1px solid var(--accent);
    border-radius: 6px;
    width: 28px; height: 28px;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
  }
  :root[data-theme="light"] .card-controls button { border-color: #aaa; }
  .card-controls button:hover { background: var(--accent); color: var(--panel); }
  :root[data-theme="light"] .card-controls button:hover { background: var(--accent); color: #fff; }
  
  .card-controls button:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    background: var(--panel);
    color: var(--text);
  }
  .card-controls button.btn-delete {
    background: var(--danger-dark);
    border-color: var(--danger);
    width: auto; padding: 0 8px;
    font-size: 13px;
    font-weight: 700;
  }
  .card-controls button.btn-load {
    background: var(--panel);
    border-color: var(--teal);
    width: auto; padding: 0 8px;
    font-size: 13px;
    font-weight: 700;
  }
  :root[data-theme="light"] .card-controls button.btn-load { border-color: var(--teal); }
  .card-controls button.btn-load:hover { background: var(--teal); color: #fff; }
  
  .explain {
    margin-top: 16px; padding: 10px; border-radius: 10px; background: #0b1519;
    color: var(--muted); font-size: 13px; line-height: 1.5;
  }
  :root[data-theme="light"] .explain { background: #eef3f5; }
  #sf_warning { color: #ff4d4d; font-size: 12px; display: none; margin-top: 6px; }

  #print-sheet { display: none; position: absolute; }
  
  .card .card-grid {
    display: grid;
    max-height: 0;
    overflow: hidden;
    margin-top: 0;
    transition: max-height 0.3s ease-out, margin-top 0.3s ease-out;
  }
  .card.active { background: linear-gradient(180deg, #0f2029, #0d1a21); }
  :root[data-theme="light"] .card.active { background: linear-gradient(180deg, #f8f8f8, #fdfdfd); }
  .card.active .card-grid {
    max-height: 500px;
    margin-top: 10px;
    transition: max-height 0.5s ease-in, margin-top 0.3s ease-in;
  }
  .card-title::before { content: '‚ñ∫ '; font-size: 10px; margin-right: 5px; }
  .card.active .card-title::before { content: '‚ñº '; }
  
  @media print {
    body > * { display: none !important; visibility: hidden !important; }
    #print-sheet, #print-sheet * { display: block !important; visibility: visible !important; }
    #print-sheet {
      position: static; width: 100%; padding: 10px; margin: 0; border: none;
      background: #fff; color: #000; box-sizing: border-box;
    }
    .print-entry { page-break-after: always; page-break-inside: avoid; padding: 10px; border-bottom: none; margin-bottom: 0; box-sizing: border-box; }
    #print-sheet h3 { color: #000; font-weight: 800; font-size: 15px; border-bottom: 2px solid #333; padding-bottom: 4px; margin-top: 0; margin-bottom: 5px; }
    #print-sheet table { width: 100%; color: #333; margin-top: 0; }
    #print-sheet td { border-bottom: 1px solid #eee; padding: 6px 8px; font-size: 11px; }
    #print-sheet td:first-child { color: #555; font-weight: normal; }
    #print-sheet td:last-child { color: #000; font-weight: 800; text-align: left; }
    .print-diagram-svg { width: 100%; background: #f9f9f9; border: 1px solid #ccc; border-radius: 8px; margin-top: 10px; padding: 10px; box-sizing: border-box; }
    .print-diagram-svg svg { display: block; max-width: 95%; margin: 0 auto; }
    #print-sheet .status-bad { color: #D00; font-weight: 800; }
    .print-diagram-svg.overloaded { border: 5px solid #D00; }
    .print-diagram-svg .dim-line { stroke: #000; marker-start: url(#arrow); marker-end: url(#arrow); }
    .print-diagram-svg .ext-line { stroke: #777; stroke-dasharray: 2 2; }
    .print-diagram-svg .dim-text { fill: #000; font-weight: 800; font-size: 14px; }
    .print-diagram-svg .float-body { stroke: #000; stroke-width: 2; }
    .print-diagram-svg .float-text-wrapper {
      display: flex; align-items: center; justify-content: center; text-align: center;
      height: 100%; width: 100%; overflow: hidden; word-break: break-word; font-size: 11px; font-weight: 800; color: #000; line-height: 1.2;
    }
    .print-diagram-svg .cable { stroke: #007bff; stroke-width: 2; }
    .print-warning-note { text-align: center; font-weight: 800; color: #D00; font-size: 10px; padding: 2px 0; margin-top: 2px; }
  }
</style>
</head>
<body>

<div class="title-container">
  <div class="title">Buoyancy & Float Planner</div>
  <button id="themeToggle" title="Toggle Theme">üåô</button>
</div>

<div class="wrap">
  <div id="mainDiagramWrap" class="panel">
    <div id="mainDiagramSVGContainer">
      </div>
  </div>

  <div class="sidebar panel">
    <h2>Cable Parameters</h2>
    <label><span>Cable Description</span><input id="cdesc" type="text" placeholder="e.g. 20mm Steel Wire"></label>
    <label><span>Cable W (kg/m)</span><input id="W" type="number" value="34"></label>
    <label><span>Buoy usable B (kg)</span><input id="B" type="number" value="200"></label>
    <label><span>Spacing (m)</span><input id="X" type="number" value="5" step="0.1"></label>
    <label><span>Safety Factor SF</span><input id="SF" type="number" value="1.2" step="0.05" min="0.5"></label>
    
    <div id="sf_warning">‚ö†Ô∏è SF &lt; 1: This is an under-float condition. The cable will sag and sit below the water surface.</div>

    <div class="explain">
      <b>How it Works</b><br>
      ‚Ä¢ <b>Coverage (Chain Failure Protection)</b>: When a cable is under-floated, the cable sags, causing a longer span of cable between floats. This increased span means each float must support more cable weight. If one float fails, the adjacent floats must absorb its share of the load plus their own increased load from the sag. Correct spacing, coupled with an appropriate safety factor, ensures that remaining floats can handle this additional load, preventing a cascading "chain failure" where one float loss leads to more failures.<br>
      ‚Ä¢ <b>Cable Weight in Water (W)</b>: This is the effective submerged mass per metre of the cable, taking into account its material density and displacement.<br>
      ‚Ä¢ <b>Buoyancy (B)</b>: Represents the usable lift capacity of each individual float (a realistic working value, not just its theoretical displacement).<br>
      ‚Ä¢ <b>Spacing (X)</b>: The centre-to-centre distance between floats. This directly determines the length of cable that each float is primarily responsible for supporting.<br>
      ‚Ä¢ <b>Safety Factor (SF)</b>: SF ‚â• 1 provides a safety margin. SF &lt; 1 means a deliberate under-float, where the cable will intentionally sag below the water surface between floats.
    </div>
  </div>

  <div class="math panel">
    <h2>Float Planner</h2>
    <label><span>Total Cable Length (m)</span><input id="clen" type="number" value="100"></label>
    <label><span>Floatation Description</span><input id="fdesc" type="text" placeholder="e.g. Doowin Single"></label>
    <label><span>Float Length (m)</span><input id="flen" type="number" value="0.8" step="0.01"></label>
    <label><span>Float Shape</span>
      <select id="fshape">
        <option value="Rectangle">Rectangle</option>
        <option value="Round / Ellipse">Round / Ellipse</option>
      </select>
    </label>
    <label><span>Float Colour</span><input id="fcolor" type="color" value="#ffff00"></label>
    <label class="full-width-input"><span>Remarks</span>
      <input id="remarks" type="text" placeholder="e.g. Tie on with 10mm rope">
    </label>
    
    <table style="margin-top: 16px;">
      <tr><td>Centre-to-centre spacing</td><td id="pt_spacing"></td></tr>
      <tr><td>Edge-to-edge spacing</td><td id="pt_edge"></td></tr>
      <tr><td>Total coverage length</td><td id="pt_cover"></td></tr>
      <tr><td>Span load check</td><td id="pt_status"></td></tr>
    </table>
    
    <div class="planner-result">
      <span>Floats Required</span>
      <div id="pt_floats_display">0</div>
    </div>

    <div class="btn-group">
      <button class="btn" onclick="saveResult()">Save Result</button>
      <button class="btn btn-secondary" onclick="printFloatPlan()">Print Float Plan</button>
    </div>
    <div class="btn-group">
      <button class="btn" onclick="clearCurrent()">Clear Current</button>
      <button class="btn" onclick="resetDefaults()">Reset All Fields</button>
    </div>

    <div id="savedCards"></div>
    <button class="btn btn-danger" style="margin-top: 10px; width: 100%;" onclick="clearAll()">Clear All Saved</button>
  </div>
</div>

<div id="print-sheet">
  </div>


<script>
// === Element Cache ===
const W=document.getElementById('W'), B=document.getElementById('B'), X=document.getElementById('X'),
      SF=document.getElementById('SF'),
      clenEl=document.getElementById('clen'), fdesc=document.getElementById('fdesc'),
      flen=document.getElementById('flen'),
      pt_spacing=document.getElementById('pt_spacing'),
      pt_edge=document.getElementById('pt_edge'),
      pt_cover=document.getElementById('pt_cover'),
      pt_status=document.getElementById('pt_status'),
      pt_floats_display=document.getElementById('pt_floats_display'),
      savedCards=document.getElementById('savedCards'),
      sf_warning=document.getElementById('sf_warning'),
      printSheet=document.getElementById('print-sheet'),
      mainDiagramSVGContainer = document.getElementById('mainDiagramSVGContainer'),
      cdesc = document.getElementById('cdesc'),
      fshape = document.getElementById('fshape'),
      fcolor = document.getElementById('fcolor'),
      remarks = document.getElementById('remarks'),
      themeToggle = document.getElementById('themeToggle');

let savedResults=[];

// === Wave Animation State ===
let waveRAF = null;
let waveState = {
  // visuals
  A_water: 8,              // amplitude of surface wave (px)
  A_cable: 6,              // amplitude of cable undulation (px)
  lambda: 260,             // wavelength (px)
  speed: 60,               // phase velocity (px/s)
  phase_cable: Math.PI/8,  // small lag so cable trails wave

  // geometry (kept in sync by updateMainDiagram)
  cableY: 120,             // baseline y for cable center
  width: 1000              // svg viewBox width
};

function resetDefaults() {
  W.value=34; B.value=200; X.value=5; SF.value=1.2;
  clenEl.value=100; fdesc.value=""; flen.value=0.8;
  cdesc.value = "";
  fshape.value = "Rectangle";
  fcolor.value = "#ffff00";
  remarks.value = "";
  clearCurrent();
  runUpdate();
}

// === Main Diagram SVG Updater ===
function updateMainDiagram() {
  const Xv = Math.max(0.01, +X.value), flenV = +flen.value, Wv = +W.value,
        Bv = Math.max(0.01, +B.value), SFv = +SF.value,
        shape = fshape.value, color = fcolor.value;

  const spanLoad = (SFv * Wv * Xv);
  const ok = spanLoad <= Bv;
  const edgeGap = Math.max(0, Xv - flenV);
  const overloadClass = ok ? '' : 'overloaded';

  const svgViewBoxW = 1000, svgViewBoxH = 260;
  const floatW_svg = 120, floatH_svg = 70;
  const cableY = 120; // keep in sync with waveState.cableY

  // keep waveState geometry aligned
  waveState.width = svgViewBoxW;
  waveState.cableY = cableY;

  let edgeGap_svg = (edgeGap / Math.max(0.01, flenV)) * floatW_svg;
  edgeGap_svg = Math.max(30, Math.min(edgeGap_svg, 400));
  const spanW_svg = floatW_svg + edgeGap_svg;

  const numFloats = Math.floor((svgViewBoxW - floatW_svg) / spanW_svg) + 1;
  const totalGroupWidth = (numFloats - 1) * spanW_svg + floatW_svg;
  const startX = (svgViewBoxW - totalGroupWidth) / 2;

  // Emit floats wrapped in <g> so we can translate them with the cable wave
  let floatsSVG = '';
  for (let i = 0; i < numFloats; i++) {
    const x = startX + i * spanW_svg;
    const cx = x + floatW_svg / 2;

    if (shape === 'Rectangle') {
      floatsSVG += `
        <g class="float-group" data-x="${cx}">
          <rect x="${x}" y="${cableY - floatH_svg/2}" width="${floatW_svg}" height="${floatH_svg}" rx="10"
                class="float-body ${overloadClass}" style="fill:${color};" />
        </g>`;
    } else {
      floatsSVG += `
        <g class="float-group" data-x="${cx}">
          <ellipse cx="${cx}" cy="${cableY}" rx="${floatW_svg/2}" ry="${floatH_svg/2}"
                   class="float-body ${overloadClass}" style="fill:${color};" />
        </g>`;
    }
  }

  let dimensionsSVG = '';
  if (numFloats > 1) {
    const f1_x = startX, f1_edge = f1_x + floatW_svg, f1_center = f1_x + floatW_svg / 2;
    const f2_x = startX + spanW_svg, f2_center = f2_x + floatW_svg / 2;
    const dimY_top = 40, dimY_bottom = 240;

    let dimTopSVG = `
      <line x1="${f1_x}" y1="${cableY - floatH_svg/2}" x2="${f1_x}" y2="${dimY_top}" class="ext-line" />
      <line x1="${f1_edge}" y1="${cableY - floatH_svg/2}" x2="${f1_edge}" y2="${dimY_top}" class="ext-line" />
      <line x1="${f1_x}" y1="${dimY_top}" x2="${f1_edge}" y2="${dimY_top}" class="dim-line" />
      <text x="${f1_center}" y="${dimY_top - 10}" class="dim-text">Float Length: ${flenV.toFixed(2)} m</text>
    `;

    const dimBottomSVG = `
      <line x1="${f1_center}" y1="${cableY + floatH_svg/2}" x2="${f1_center}" y2="${dimY_bottom}" class="ext-line" />
      <line x1="${f2_center}" y1="${cableY + floatH_svg/2}" x2="${f2_center}" y2="${dimY_bottom}" class="ext-line" />
      <line x1="${f1_center}" y1="${dimY_bottom}" x2="${f2_center}" y2="${dimY_bottom}" class="dim-line" />
      <text x="${f1_center + spanW_svg/2}" y="${dimY_bottom - 10}" class="dim-text">Center-to-Center: ${Xv.toFixed(2)} m</text>
    `;

    if (numFloats > 2) {
      const f2_edge = f2_x + floatW_svg;
      const f3_x = startX + 2 * spanW_svg;
      dimTopSVG += `
        <line x1="${f2_edge}" y1="${cableY - floatH_svg/2}" x2="${f2_edge}" y2="${dimY_top}" class="ext-line" />
        <line x1="${f3_x}" y1="${cableY - floatH_svg/2}" x2="${f3_x}" y2="${dimY_top}" class="ext-line" />
        <line x1="${f2_edge}" y1="${dimY_top}" x2="${f3_x}" y2="${dimY_top}" class="dim-line" />
        <text x="${f2_edge + edgeGap_svg/2}" y="${dimY_top - 10}" class="dim-text">Edge-to-Edge: ${edgeGap.toFixed(2)} m</text>
      `;
    } else {
      dimTopSVG += `
        <line x1="${f1_edge}" y1="${cableY - floatH_svg/2}" x2="${f1_edge}" y2="${dimY_top}" class="ext-line" />
        <line x1="${f2_x}" y1="${cableY - floatH_svg/2}" x2="${f2_x}" y2="${dimY_top}" class="ext-line" />
        <line x1="${f1_edge}" y1="${dimY_top}" x2="${f2_x}" y2="${dimY_top}" class="dim-line" />
        <text x="${f1_edge + edgeGap_svg/2}" y="${dimY_top - 10}" class="dim-text">Edge-to-Edge: ${edgeGap.toFixed(2)} m</text>
      `;
    }

    dimensionsSVG = dimTopSVG + dimBottomSVG;
  }

  const svgContent = `
    <svg id="main-svg" class="main-svg" width="100%" height="${svgViewBoxH}"
         viewBox="0 0 ${svgViewBoxW} ${svgViewBoxH}" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <marker id="arrow-main" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--accent)" />
        </marker>
      </defs>

      <!-- Animated cable path (behind floats) -->
      <path id="cable-path" class="cable" d="" />

      <!-- Surface wave indicator -->
      <path id="wave-path" class="wave" d="" />

      ${floatsSVG}
      ${dimensionsSVG}
    </svg>
  `;
  mainDiagramSVGContainer.innerHTML = svgContent;

  // Kick / re-kick the animation after re-render
  startWaveAnimation();
}

// === Wave Animation Loop ===
function startWaveAnimation() {
  if (waveRAF) cancelAnimationFrame(waveRAF);

  const svg = document.getElementById('main-svg');
  if (!svg) return;

  const wavePath    = document.getElementById('wave-path');
  const cablePath   = document.getElementById('cable-path');
  const floatGroups = Array.from(svg.querySelectorAll('.float-group'));

  const { A_water, A_cable, lambda, speed, cableY, width, phase_cable } = waveState;
  const k = (2 * Math.PI) / lambda;   // spatial frequency
  const w = k * speed;                 // angular frequency (phase travels at "speed")
  const step = 6;                      // x step for path resolution

  let t0 = performance.now();

  function frame(now) {
    const t = (now - t0) / 1000; // seconds

    // Surface wave path
    let dWater = '';
    for (let x = 0; x <= width; x += step) {
      const y = cableY + A_water * Math.sin(k * x - w * t);
      dWater += (x === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
    }
    wavePath.setAttribute('d', dWater);

    // Cable path (slightly smaller amplitude + small phase lag)
    let dCable = '';
    for (let x = 0; x <= width; x += step) {
      const y = cableY + A_cable * Math.sin(k * x - w * t + phase_cable);
      dCable += (x === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
    }
    cablePath.setAttribute('d', dCable);

    // Floats ride the cable‚Äôs displacement at their x-position
    for (const g of floatGroups) {
      const x = parseFloat(g.getAttribute('data-x')) || 0;
      const yOffset = A_cable * Math.sin(k * x - w * t + phase_cable);
      g.setAttribute('transform', `translate(0, ${yOffset.toFixed(2)})`);
    }

    waveRAF = requestAnimationFrame(frame);
  }

  waveRAF = requestAnimationFrame(frame);
}

// === Planner ===
function updatePlanner() {
  const Xv=Math.max(0.01, +X.value), clen=+clenEl.value, Wv=+W.value,
        Bv=Math.max(0.01, +B.value), SFv=+SF.value, flenV=+flen.value;

  sf_warning.style.display = (SFv < 1) ? "block" : "none";

  const edgeGap = Math.max(0, Xv - flenV);
  const floatsNeeded = Math.ceil(clen / Xv);
  const coverage = (floatsNeeded * Xv).toFixed(1);
  const spanLoadNum = (SFv * Wv * Xv);
  const ok = spanLoadNum <= Bv;
  const spanLoadStr = spanLoadNum.toFixed(1);

  pt_spacing.innerText = `${Xv.toFixed(2)} m`;
  pt_edge.innerText = `${edgeGap.toFixed(2)} m`;
  pt_cover.innerText = `${coverage} m`;

  pt_status.innerHTML = ok
    ? `<span class="status-ok">‚úÖ OK (${spanLoadStr} ‚â§ ${Bv})</span>`
    : `<span class="status-bad">‚ùå Overload (${spanLoadStr} > ${Bv})</span>`;

  pt_floats_display.innerText = floatsNeeded.toLocaleString('en-US');
}

// === LocalStorage Functions ===
function savePlansToStorage() {
  localStorage.setItem('buoyancyPlans', JSON.stringify(savedResults));
}
function loadPlansFromStorage() {
  savedResults = JSON.parse(localStorage.getItem('buoyancyPlans')) || [];
}

// === Save / Clear Functions ===
function clearCurrent() {
  pt_spacing.innerText = "";
  pt_edge.innerText = "";
  pt_cover.innerText = "";
  pt_status.innerText = "";
  fdesc.value = "";
  remarks.value = "";
  pt_floats_display.innerText = "0";
}

function saveResult() {
  const Xv=Math.max(0.01, +X.value), clen=+clenEl.value, Wv=+W.value,
        Bv=Math.max(0.01, +B.value), SFv=+SF.value, flenV=+flen.value;
  const desc=fdesc.value.trim() || "Unnamed Floatation";
  const cdescV = cdesc.value.trim() || "Unknown Cable";
  const fshapeV = fshape.value;
  const fcolorV = fcolor.value;
  const remarksV = remarks.value.trim();

  const edgeGap = Math.max(0, Xv - flenV);
  const floatsNeeded = Math.ceil(clen / Xv);
  const coverage = (floatsNeeded * Xv).toFixed(1);
  const spanLoadNum = (SFv * Wv * Xv);
  const ok = spanLoadNum <= Bv;

  savedResults.push({
    desc, cdescV, fshapeV, fcolorV, Wv, remarksV, SFv,
    Xv, clen, floatsNeeded, coverage,
    spanLoad: spanLoadNum.toFixed(1),
    Bv, ok, flenV, edgeGap
  });
  renderCards();
  savePlansToStorage();
}

// MODIFIED: This is the correct renderCards function with accordion logic and Load button
function renderCards() {
  savedCards.innerHTML = "";
  savedResults.forEach((r, i) => {
    const card = document.createElement('div');
    card.className = 'card';

    const cardHead = document.createElement('div');
    cardHead.className = 'card-head';
    cardHead.innerHTML = `
      <div class="card-title">${r.desc}</div>
      <div class="card-controls">
        <button title="Move Up" ${i === 0 ? 'disabled' : ''} onclick="moveCard(event, ${i}, -1)">‚ñ≤</button>
        <button title="Move Down" ${i === savedResults.length - 1 ? 'disabled' : ''} onclick="moveCard(event, ${i}, 1)">‚ñº</button>
        <button title="Delete" class="btn-delete" onclick="deleteCard(event, ${i})">Delete</button>
      </div>
    `;

    const cardGrid = document.createElement('div');
    cardGrid.className = 'card-grid';
    cardGrid.innerHTML = `
      <div>Cable Type</div><div>${r.cdescV}</div>
      <div>Cable W (kg/m)</div><div>${r.Wv} kg/m</div>
      <div>Float Shape</div><div>${r.fshapeV}</div>
      <div>Float Colour</div><div class="card-grid-color" style="background-color: ${r.fcolorV};"></div>
      <div>Cable length</div><div>${r.clen} m</div>
      <div>Float length</div><div>${r.flenV.toFixed(2)} m</div>
      <div>Spacing</div><div>${r.Xv.toFixed(2)} m</div>
      <div>Edge gap</div><div>${r.edgeGap.toFixed(2)} m</div>
      <div>Floats required</div><div>${r.floatsNeeded.toLocaleString('en-US')}</div>
      <div>Remarks</div><div>${r.remarksV || 'N/A'}</div>
      <div>Status</div><div class="${r.ok ? 'status-ok' : 'status-bad'}">${r.ok ? '‚úÖ OK' : '‚ùå Overload'}</div>
    `;

    cardHead.addEventListener('click', (e) => {
      if (e.target.closest('.card-controls')) return;
      card.classList.toggle('active');
    });

    card.appendChild(cardHead);
    card.appendChild(cardGrid);
    savedCards.appendChild(card);
  });
}

// MODIFIED: Correct Up/Down/Delete functions
function moveCard(e, index, direction) {
  e.stopPropagation();
  if (direction === -1 && index === 0) return;
  if (direction === 1 && index === savedResults.length - 1) return;

  const newIndex = index + direction;
  const item = savedResults[index];
  savedResults[index] = savedResults[newIndex];
  savedResults[newIndex] = item;

  renderCards();
  savePlansToStorage();
}

function deleteCard(e, i) {
  e.stopPropagation();
  savedResults.splice(i, 1);
  renderCards();
  savePlansToStorage();
}

function clearAll() {
  if (confirm("Are you sure you want to delete all saved results?")) {
    savedResults = [];
    renderCards();
    savePlansToStorage();
  }
}

// === Print Function ===
function generateInstallSheetHTML() {
  printSheet.innerHTML = "";

  if (savedResults.length === 0) {
    printSheet.innerHTML = "No saved results to print. Please configure and save a result first.";
    return false;
  }

  savedResults.forEach(r => {
    const sfClass = r.SFv < 1 ? 'class="status-bad"' : '';

    const summaryHTML = `
      <h3>Project Summary</h3>
      <table>
        <tr><td>Cable Description</td><td>${r.cdescV}</td></tr>
        <tr><td>Cable W (kg/m)</td><td>${r.Wv} kg/m</td></tr>
        <tr><td>Floatation Description</td><td>${r.desc}</td></tr>
        <tr><td>Float Buoyancy (B)</td><td>${r.Bv} kg</td></tr>
        <tr ${sfClass}><td>Safety Factor (SF)</td><td>${r.SFv}</td></tr>
        <tr><td>Total Cable Length</td><td>${r.clen.toLocaleString('en-US')} m</td></tr>
        <tr><td>Total Floats Required</td><td>${r.floatsNeeded.toLocaleString('en-US')}</td></tr>
        <tr><td>Remarks</td><td>${r.remarksV || 'N/A'}</td></tr>
        ${!r.ok ? `<tr><td>Status</td><td class="status-bad">‚ùå OVERLOAD (${r.spanLoad} > ${r.Bv})</td></tr>` : ''}
      </table>
    `;

    const desc = r.desc.length > 15 ? r.desc.substring(0,12)+'...' : r.desc;

    const totalW_print = 750;
    const floatW_print = 100;
    const floatH_print = 50;
    const gapW_print = 350;

    const contentW_print = floatW_print + gapW_print + floatW_print;
    const f1_x_print = (totalW_print - contentW_print) / 2;

    const f1_edge_print = f1_x_print + floatW_print;
    const f1_center_print = f1_x_print + floatW_print / 2;

    const f2_x_print = f1_edge_print + gapW_print;
    const f2_center_print = f2_x_print + floatW_print / 2;

    const cableY_print = 120;
    const dimY_top_print = 40;
    const dimY_bottom_print = 240;

    const textWrapper = (x_pos) => `
      <foreignObject
        x="${x_pos + 5}"
        y="${cableY_print - floatH_print/2 + 5}"
        width="${floatW_print - 10}"
        height="${floatH_print - 10}">
          <div xmlns="http://www.w3.org/1999/xhtml" class="float-text-wrapper">
            ${r.desc}
          </div>
      </foreignObject>
    `;

    let floatShapeSVG_print = '';
    if (r.fshapeV === 'Rectangle') {
      floatShapeSVG_print = `
        <rect x="${f1_x_print}" y="${cableY_print - floatH_print/2}" width="${floatW_print}" height="${floatH_print}" rx="8" class="float-body" style="fill: ${r.fcolorV};"/>
        ${textWrapper(f1_x_print)}
        <rect x="${f2_x_print}" y="${cableY_print - floatH_print/2}" width="${floatW_print}" height="${floatH_print}" rx="8" class="float-body" style="fill: ${r.fcolorV};"/>
        ${textWrapper(f2_x_print)}
      `;
    } else {
      floatShapeSVG_print = `
        <ellipse cx="${f1_center_print}" cy="${cableY_print}" rx="${floatW_print/2}" ry="${floatH_print/2}" class="float-body" style="fill: ${r.fcolorV};"/>
        ${textWrapper(f1_x_print)}
        <ellipse cx="${f2_center_print}" cy="${cableY_print}" rx="${floatW_print/2}" ry="${floatH_print/2}" class="float-body" style="fill: ${r.fcolorV};"/>
        ${textWrapper(f2_x_print)}
      `;
    }

    let overloadWatermark = '';
    if (!r.ok) {
      overloadWatermark = `
        <g fill="rgba(210, 0, 0, 0.2)" stroke="rgba(210, 0, 0, 0.2)" stroke-width="5" text-anchor="middle">
          <line x1="50" y1="50" x2="700" y2="220"/>
          <line x1="50" y1="220" x2="700" y2="50"/>
          <text x="375" y="150" font-size="60" font-weight="800">OVERLOAD</text>
        </g>
      `;
    }
    const diagramClass = r.ok ? '' : 'overloaded';

    const diagramHTML = `
      <h3>Spacing Diagram</h3>
      <div class="print-diagram-svg ${diagramClass}">
        <svg width="100%" height="240" viewBox="0 0 ${totalW_print} 240" xmlns="http://www.w3.org/2000/svg"
             style="font-size: 14px;">
          <defs>
            <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#000" />
            </marker>
            <style>
              .dim-line { stroke: #000; stroke-width: 1; marker-start: url(#arrow); marker-end: url(#arrow); }
              .ext-line { stroke: #777; stroke-width: 1; stroke-dasharray: 2 2; }
              .dim-text { fill: #000; font-weight: 800; font-size: 14px; text-anchor: middle; }
              .float-body { stroke: #000; stroke-width: 2; }
              .cable { stroke: #007bff; stroke-width: 3; }
              .float-text-wrapper {
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
                height: 100%;
                width: 100%;
                overflow: hidden;
                word-break: break-word;
                font-size: 11px;
                font-weight: 800;
                color: #000;
                line-height: 1.2;
              }
            </style>
          </defs>
          <line x1="0" y1="${cableY_print}" x2="${totalW_print}" y2="${cableY_print}" class="cable" />
          ${floatShapeSVG_print}

          <line x1="${f1_x_print}" y1="${cableY_print - floatH_print/2}" x2="${f1_x_print}" y2="${dimY_top_print}" class="ext-line" />
          <line x1="${f1_edge_print}" y1="${cableY_print - floatH_print/2}" x2="${f1_edge_print}" y2="${dimY_top_print}" class="ext-line" />
          <line x1="${f1_x_print}" y1="${dimY_top_print}" x2="${f1_edge_print}" y2="${dimY_top_print}" class="dim-line" />
          <text x="${f1_center_print}" y="${dimY_top_print - 10}" class="dim-text">Float Length: ${r.flenV.toFixed(2)} m</text>

          <line x1="${f1_edge_print}" y1="${cableY_print - floatH_print/2}" x2="${f1_edge_print}" y2="${dimY_top_print}" class="ext-line" />
          <line x1="${f2_x_print}" y1="${cableY_print - floatH_print/2}" x2="${f2_x_print}" y2="${dimY_top_print}" class="ext-line" />
          <line x1="${f1_edge_print}" y1="${dimY_top_print}" x2="${f2_x_print}" y2="${dimY_top_print}" class="dim-line" />
          <text x="${f1_edge_print + (gapW_print/2)}" y="${dimY_top_print - 10}" class="dim-text">Edge-to-Edge: ${r.edgeGap.toFixed(2)} m</text>

          <line x1="${f1_center_print}" y1="${cableY_print + floatH_print/2}" x2="${f1_center_print}" y2="${dimY_bottom_print}" class="ext-line" />
          <line x1="${f2_center_print}" y1="${cableY_print + floatH_print/2}" x2="${f2_center_print}" y2="${dimY_bottom_print}" class="ext-line" />
          <line x1="${f1_center_print}" y1="${dimY_bottom_print}" x2="${f2_center_print}" y2="${dimY_bottom_print}" class="dim-line" />
          <text x="${f1_center_print + (f2_center_print-f1_center_print)/2}" y="${dimY_bottom_print - 10}" class="dim-text">Center-to-Center: ${r.Xv.toFixed(2)} m</text>

          ${overloadWatermark}
        </svg>
      </div>
    `;

    const warningNoteHTML = r.SFv < 1 ? `
      <div class="print-warning-note">
        <strong>‚ö†Ô∏è LOW SAFETY FACTOR</strong><br>
        An SF less than 1 indicates an under-float condition. The cable will sag below the water surface. This is not advised for standard operations and should only be used in limited circumstances, such as for deliberate sinkage.
      </div>
    ` : '';

    printSheet.innerHTML += `<div class="print-entry">${summaryHTML}${diagramHTML}${warningNoteHTML}</div>`;
  });
  return true;
}

function printFloatPlan() {
  const success = generateInstallSheetHTML();
  if (success) {
    window.print();
  } else {
    alert("No saved results to print. Please save a float plan first.");
  }
}

// === Theme Toggle Function ===
function toggleTheme() {
  const currentTheme = document.documentElement.dataset.theme;
  if (currentTheme === 'light') {
    document.documentElement.dataset.theme = 'dark';
    themeToggle.innerText = 'üåô';
    localStorage.setItem('buoyancyTheme', 'dark');
  } else {
    document.documentElement.dataset.theme = 'light';
    themeToggle.innerText = '‚òÄÔ∏è';
    localStorage.setItem('buoyancyTheme', 'light');
  }
}

// === Initializer ===
function runUpdate() {
  updatePlanner();
  updateMainDiagram();
}

// Add event listeners
[W, B, X, SF, clenEl, flen, fshape, fcolor].forEach(el => el.addEventListener('input', runUpdate));
themeToggle.addEventListener('click', toggleTheme);

// Initial load
function init() {
  const savedTheme = localStorage.getItem('buoyancyTheme') || 'dark';
  document.documentElement.dataset.theme = savedTheme;
  themeToggle.innerText = savedTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';

  loadPlansFromStorage();

  resetDefaults();
  renderCards();
}

init();
</script>

</body>
</html>
